
#include "/Engine/Public/Platform.ush"


void MainVS(
    in uint GlobalVertexId : SV_VertexID,
    out float4 OutPosition : SV_Position
    )
{
    // Compute the cell index.
    uint GridCellIndex = GlobalVertexId / 6;

    // Compute row and column id of the cell within the grid.
    uint GridColumnId = GridCellIndex;
    uint GridRowId = GridCellIndex - GridColumnId;

    // Compute the vertex id within a 2 triangles grid cell.
    uint VertexId = GlobalVertexId - GridCellIndex * 6;

    // Compute the bottom left originated UV coordinate of the triangle's vertex within the cell.
    float2 CellVertexUV = float2(0x1 & ((VertexId + 1) / 3), VertexId & 0x1);

    // Compute the top left originated UV of the vertex within the grid.
    float2 GridVertexUV = CellVertexUV + float2(GridColumnId, GridRowId);

    // Output vertex position.
    OutPosition = float4(GridVertexUV * 2 - 1, 0.0, 1);
}


float2 OutputSize;
float4x4 Cam0_CamMtx;
float4x4 Cam1_CamMtx;
float4x4 Cam2_CamMtx;
float4x4 Cam3_CamMtx;
float4x4 Cam4_IViewMtx;
Texture2D Tex0;
Texture2D Tex1;
Texture2D Tex2;
Texture2D Tex3;


void MainPS(
    in float4 SvPosition : SV_Position,
    out float4 OutColor : SV_Target0
    )
{
    float2 uv1 = SvPosition.xy / OutputSize;            // [ 0, 1]
    float2 ndc = float2(2 * uv1.x - 1, 1 - 2 * uv1.y);  // [-1, 1]

    float scale = 500;
    float4 CameraSpace = float4(scale * float3(ndc, 1.05), 1.0);
    float4 WorldSpace = mul(CameraSpace, Cam4_IViewMtx);
    WorldSpace /= WorldSpace.w;

    int3 location = int3(0, 0, 0);
    float4x4 cam_mts[4] = {Cam0_CamMtx, Cam1_CamMtx, Cam2_CamMtx, Cam3_CamMtx};
    float min_dist = 3.402e38;
    int id = -1;

    for (int i = 0; i < 4; ++i) {
        float4 result = mul(WorldSpace, cam_mts[i]);
        if (result.w <= 0) continue;
        float2 ProjectionSpace = result.xy / result.w;
        float dist = length(ProjectionSpace);
        if (dist < min_dist) {
            id = i;
            min_dist = dist;
            float2 uv2 = 0.5 * float2(ProjectionSpace.x, -ProjectionSpace.y) + 0.5;
            location.xy = uv2 * OutputSize;
        }
    }
    
    switch (id) {
        case 0: OutColor = Tex0.Load(location); break;
        case 1: OutColor = Tex1.Load(location); break;
        case 2: OutColor = Tex2.Load(location); break;
        case 3: OutColor = Tex3.Load(location); break;
        default: OutColor = float4(0, 0, 0, 0); break;
    }
}
